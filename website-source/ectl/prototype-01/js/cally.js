class se { #t; #e = new Set; constructor(t) { this.#t = t } get current() { return this.#t } set current(t) { this.#t != t && (this.#t = t, this.#e.forEach((e => e(t)))) } on(t) { return this.#e.add(t), () => this.#e.delete(t) } } const At = t => new se(t), nt = Symbol.for("atomico.hooks"); globalThis[nt] = globalThis[nt] || {}; let O = globalThis[nt]; const oe = Symbol.for("Atomico.suspense"), Ft = Symbol.for("Atomico.effect"), re = Symbol.for("Atomico.layoutEffect"), Rt = Symbol.for("Atomico.insertionEffect"), M = (t, e, n) => { const { i: o, hooks: r } = O.c, a = r[o] = r[o] || {}; return a.value = t(a.value), a.effect = e, a.tag = n, O.c.i++, r[o].value }, ae = t => M(((e = At(t)) => e)), _ = () => M(((t = At(O.c.host)) => t)), $t = () => O.c.update, ce = (t, e, n = 0) => { let o = {}, r = !1; const a = (t, e) => { for (const n in o) { const r = o[n]; r.effect && r.tag === t && (r.value = r.effect(r.value, e)) } }; return { load: a => { let s; O.c = { host: e, hooks: o, update: t, i: 0, id: n }; try { r = !1, s = a() } catch (t) { if (t !== oe) throw t; r = !0 } finally { O.c = null } return s }, cleanEffects: t => (a(Rt, t), () => (a(re, t), () => { a(Ft, t) })), isSuspense: () => r } }, A = Symbol.for; function It(t, e) { const n = t.length; if (n !== e.length) return !1; for (let o = 0; o < n; o++) { if (t[o] !== e[o]) return !1 } return !0 } const T = t => "function" == typeof t, R = t => "object" == typeof t, { isArray: ie } = Array, st = (t, e) => (!e || t instanceof HTMLStyleElement) && "hydrate" in (t?.dataset || {}); function Ut(t, e) { let n; const o = t => { let { length: r } = t; for (let a = 0; a < r; a++) { const r = t[a]; if (r && Array.isArray(r)) o(r); else { const t = typeof r; if (null == r || "function" === t || "boolean" === t) continue; "string" === t || "number" === t ? (null == n && (n = ""), n += r) : (null != n && (e(n), n = null), e(r)) } } }; o(t), null != n && e(n) } const Lt = (t, e, n) => (t.addEventListener(e, n), () => t.removeEventListener(e, n)); class _t { constructor(t, e, n) { this.message = e, this.target = t, this.value = n } } class jt extends _t { } class le extends _t { } const x = "Custom", ue = null, fe = { true: 1, "": 1, 1: 1 }; function de(t, e, n, o, r) { const { type: a, reflect: s, event: i, value: c, attr: l = he(e) } = n?.name != x && R(n) && n != ue ? n : { type: n }, u = a?.name === x && a.map, d = null != c ? a != Function && T(c) ? c : () => c : null; Object.defineProperty(t, e, { configurable: !0, set(t) { const n = this[e]; d && a != Boolean && null == t && (t = d()); const { error: o, value: r } = (u ? pe : be)(a, t); if (o && null != r) throw new jt(this, `The value defined for prop '${e}' must be of type '${a.name}'`, r); n != r && (this._props[e] = r ?? void 0, this.update(), i && Yt(this, i), this.updated.then((() => { s && (this._ignoreAttr = l, me(this, a, l, this[e]), this._ignoreAttr = null) }))) }, get() { return this._props[e] } }), d && (r[e] = d()), o[l] = { prop: e, type: a } } const Yt = (t, { type: e, base: n = CustomEvent, ...o }) => t.dispatchEvent(new n(e, o)), he = t => t.replace(/([A-Z])/g, "-$1").toLowerCase(), me = (t, e, n, o) => null == o || e == Boolean && !o ? t.removeAttribute(n) : t.setAttribute(n, e?.name === x && e?.serialize ? e?.serialize(o) : R(o) ? JSON.stringify(o) : e == Boolean ? "" : o), ye = (t, e) => t == Boolean ? !!fe[e] : t == Number ? Number(e) : t == String ? e : t == Array || t == Object ? JSON.parse(e) : t.name == x ? e : new t(e), pe = ({ map: t }, e) => { try { return { value: t(e), error: !1 } } catch { return { value: e, error: !0 } } }, be = (t, e) => null == t || null == e ? { value: e, error: !1 } : t != String && "" === e ? { value: void 0, error: !1 } : t == Object || t == Array || t == Symbol ? { value: e, error: {}.toString.call(e) !== `[object ${t.name}]` } : e instanceof t ? { value: e, error: t == Number && Number.isNaN(e.valueOf()) } : t == String || t == Number || t == Boolean ? { value: e, error: t == Number ? "number" != typeof e || Number.isNaN(e) : t == String ? "string" != typeof e : "boolean" != typeof e } : { value: e, error: !0 }; let ge = 0; const ve = t => (t?.dataset || {})?.hydrate || "" || "c" + ge++, j = (t, e = HTMLElement) => { const n = {}, o = {}, r = "prototype" in e && e.prototype instanceof Element, a = r ? e : "base" in e ? e.base : HTMLElement, { props: s, styles: i } = r ? t : e; return class extends a { constructor() { super(), this._setup(), this._render = () => t({ ...this._props }); for (const t in o) this[t] = o[t] } static get styles() { return [super.styles, i] } async _setup() { if (this._props) return; let t, e; this._props = {}, this.mounted = new Promise((n => this.mount = () => { n(), t != this.parentNode && (e != t ? this.unmounted.then(this.update) : this.update()), t = this.parentNode })), this.unmounted = new Promise((o => this.unmount = () => { o(), (t != this.parentNode || !this.isConnected) && (n.cleanEffects(!0)()(), e = this.parentNode, t = null) })), this.symbolId = this.symbolId || Symbol(), this.symbolIdParent = Symbol(); const n = ce((() => this.update()), this, ve(this)); let o, r = !0; const a = st(this); this.update = () => (o || (o = !0, this.updated = (this.updated || this.mounted).then((() => { try { const t = n.load(this._render), e = n.cleanEffects(); return t && t.render(this, this.symbolId, a), o = !1, r && !n.isSuspense() && (r = !1, !a && Ee(this)), e() } finally { o = !1 } })).then((t => { t && t() }))), this.updated), this.update() } connectedCallback() { this.mount(), super.connectedCallback && super.connectedCallback() } disconnectedCallback() { super.disconnectedCallback && super.disconnectedCallback(), this.unmount() } attributeChangedCallback(t, e, o) { if (n[t]) { if (t === this._ignoreAttr || e === o) return; const { prop: r, type: a } = n[t]; try { this[r] = ye(a, o) } catch { throw new le(this, `The value defined as attr '${t}' cannot be parsed by type '${a.name}'`, o) } } else super.attributeChangedCallback(t, e, o) } static get props() { return { ...super.props, ...s } } static get observedAttributes() { const t = super.observedAttributes || []; for (const t in s) de(this.prototype, t, s[t], n, o); return Object.keys(n).concat(t) } } }; function Ee(t) { const { styles: e } = t.constructor, { shadowRoot: n } = t; if (n && e.length) { const t = []; Ut(e, (e => { e && (e instanceof Element ? n.appendChild(e.cloneNode(!0)) : t.push(e)) })), t.length && (n.adoptedStyleSheets = t) } } const Bt = t => (e, n) => { M((([t, e] = []) => ((e || !e) && (e && It(e, n) ? t = t || !0 : (T(t) && t(), t = null)), [t, n])), (([t, n], o) => o ? (T(t) && t(), []) : [t || e(), n]), t) }, U = Bt(Ft), De = Bt(Rt); class qt extends Array { constructor(t, e) { let n = !0; const o = t => { try { e(t, this, n) } finally { n = !1 } }; super(void 0, o, e), o(t) } } const ct = t => { const e = $t(); return M(((n = new qt(t, ((t, n, o) => { (t = T(t) ? t(n[0]) : t) !== n[0] && (n[0] = t, o || e()) }))) => n)) }, C = (t, e) => { const [n] = M((([n, o, r = 0] = []) => ((!o || o && !It(o, e)) && (n = t()), [n, e, r]))); return n }, it = t => { const { current: e } = _(); if (!(t in e)) throw new jt(e, `For useProp("${t}"), the prop does not exist on the host.`, t); return M(((n = new qt(e[t], ((n, o) => { n = T(n) ? n(e[t]) : n, e[t] = n }))) => (n[0] = e[t], n))) }, P = (t, e = {}) => { const n = _(); return n[t] || (n[t] = (o = e.detail) => Yt(n.current, { type: t, ...e, detail: o })), n[t] }, ot = A("atomico/options"); globalThis[ot] = globalThis[ot] || { sheet: !!document.adoptedStyleSheets }; const xt = globalThis[ot], Se = { checked: 1, value: 1, selected: 1 }, we = { list: 1, type: 1, size: 1, form: 1, width: 1, height: 1, src: 1, href: 1, slot: 1 }, Te = { shadowDom: 1, staticNode: 1, cloneNode: 1, children: 1, key: 1 }, q = {}, rt = []; class at extends Text { } const Ce = A("atomico/id"), $ = A("atomico/type"), X = A("atomico/ref"), zt = A("atomico/vnode"), Pe = () => { }; function Ne(t, e, n) { return Kt(this, t, e, n) } const Ht = (t, e, ...n) => { const o = e || q; let { children: r } = o; if (r = r ?? (n.length ? n : rt), t === Pe) return r; const a = t ? t instanceof Node ? 1 : t.prototype instanceof HTMLElement && 2 : 0; if (!1 === a && t instanceof Function) return t(r != rt ? { children: r, ...o } : o); const s = xt.render || Ne; return { [$]: zt, type: t, props: o, children: r, key: o.key, shadow: o.shadowDom, static: o.staticNode, raw: a, is: o.is, clone: o.cloneNode, render: s } }; function Kt(t, e, n = Ce, o, r) { let a; if (e && e[n] && e[n].vnode == t || t[$] != zt) return e; (t || !e) && (r = r || "svg" == t.type, a = "host" != t.type && (1 == t.raw ? (e && t.clone ? e[X] : e) != t.type : 2 == t.raw ? !(e instanceof t.type) : e ? e[X] || e.localName != t.type : !e), a && null != t.type && (1 == t.raw && t.clone ? (o = !0, (e = t.type.cloneNode(!0))[X] = t.type) : e = 1 == t.raw ? t.type : 2 == t.raw ? new t.type : r ? document.createElementNS("http://www.w3.org/2000/svg", t.type) : document.createElement(t.type, t.is ? { is: t.is } : void 0))); const s = e[n] ? e[n] : q, { vnode: i = q, cycle: c = 0 } = s; let { fragment: l, handlers: u } = s; const { children: d = rt, props: h = q } = i; if (u = a ? {} : u || {}, t.static && !a) return e; if (t.shadow && !e.shadowRoot && e.attachShadow({ mode: "open", ...t.shadow }), t.props != h && Me(e, h, t.props, u, r), t.children !== d) { const a = t.shadow ? e.shadowRoot : e; l = Oe(t.children, l, a, n, !c && o, (!r || "foreignObject" != t.type) && r) } return e[n] = { vnode: t, handlers: u, fragment: l, cycle: c + 1 }, e } function ke(t, e) { const n = new at(""), o = new at(""); let r; if (t[e ? "prepend" : "append"](n), e) { let { lastElementChild: e } = t; for (; e;) { const { previousElementSibling: t } = e; if (st(e, !0) && !st(t, !0)) { r = e; break } e = t } } return r ? r.before(o) : t.append(o), { markStart: n, markEnd: o } } function Oe(t, e, n, o, r, a) { t = null == t ? null : ie(t) ? t : [t]; const s = e || ke(n, r), { markStart: i, markEnd: c, keyes: l } = s; let u; const d = l && new Set; let h = i; if (t && Ut(t, (t => { if ("object" == typeof t && !t[$]) return; const e = t[$] && t.key, s = l && null != e && l.get(e); h != c && h === s ? d.delete(h) : h = h == c ? c : h.nextSibling; const i = l ? s : h; let p = i; if (t[$]) p = Kt(t, i, o, r, a); else { const e = t + ""; !(p instanceof Text) || p instanceof at ? p = new Text(e) : p.data != e && (p.data = e) } p != h && (l && d.delete(p), !i || l ? (n.insertBefore(p, h), l && h != c && d.add(h)) : i == c ? n.insertBefore(p, c) : (n.replaceChild(p, i), h = p)), null != e && (u = u || new Map, u.set(e, p)) })), h = h == c ? c : h.nextSibling, e && h != c) for (; h != c;) { const t = h; h = h.nextSibling, t.remove() } return d && d.forEach((t => t.remove())), s.keyes = u, s } function Me(t, e, n, o, r) { for (const a in e) !(a in n) && St(t, a, e[a], null, r, o); for (const a in n) St(t, a, e[a], n[a], r, o) } function St(t, e, n, o, r, a) { if (n = n ?? null, o = o ?? null, (e = "class" != e || r ? e : "className") in t && Se[e] && (n = t[e]), o !== n && !Te[e] && "_" != e[0]) if ("o" == e[0] && "n" == e[1] && (T(o) || T(n))) Ae(t, e.slice(2), o, a); else if ("ref" == e) o && (T(o) ? o(t) : o.current = t); else if ("style" == e) { const { style: e } = t; o = o || ""; const r = R(n = n || ""), a = R(o); if (r) for (const t in n) { if (!a) break; !(t in o) && wt(e, t, null) } if (a) for (const t in o) { const a = o[t]; r && n[t] === a || wt(e, t, a) } else e.cssText = o } else { const a = "$" == e[0] ? e.slice(1) : e; a === e && (!r && !we[e] && e in t || T(o) || T(n)) ? t[e] = o ?? "" : null == o ? t.removeAttribute(a) : t.setAttribute(a, R(o) ? JSON.stringify(o) : o) } } function Ae(t, e, n, o) { if (o.handleEvent || (o.handleEvent = e => o[e.type].call(t, e)), n) { if (!o[e]) { const r = n.capture || n.once || n.passive ? Object.assign({}, n) : null; t.addEventListener(e, o, r) } o[e] = n } else o[e] && (t.removeEventListener(e, o), delete o[e]) } function wt(t, e, n) { let o = "setProperty"; null == n && (o = "removeProperty", n = null), ~e.indexOf("-") ? t[o](e, n) : t[e] = n } const Tt = {}; function H(t, ...e) { const n = (t.raw || t).reduce(((t, n, o) => t + n + (e[o] || "")), ""); return Tt[n] = Tt[n] || Fe(n) } function Fe(t) { if (xt.sheet) { const e = new CSSStyleSheet; return e.replaceSync(t), e } { const e = document.createElement("style"); return e.textContent = t, e } } const Re = Ht("host", { style: "display: contents" }), G = A("atomico/context"), $e = (t, e) => { const n = _(); De((() => Lt(n.current, "ConnectContext", (n => { t === n.detail.id && (n.stopPropagation(), n.detail.connect(e)) }))), [t]) }, Ie = t => { const e = P("ConnectContext", { bubbles: !0, composed: !0 }), n = () => { let n; return e({ id: t, connect(t) { n = t } }), n }, [o, r] = ct(n); return U((() => { o || (t[G] || (t[G] = customElements.whenDefined((new t).localName)), t[G].then((() => r(n)))) }), [t]), o }, Ue = t => { const e = Ie(t), n = $t(); return U((() => { if (e) return Lt(e, "UpdatedValue", n) }), [e]), (e || t).value }, Le = t => { const e = j((() => ($e(e, _().current), Re)), { props: { value: { type: Object, event: { type: "UpdatedValue" }, value: () => t } } }); return e.value = t, e }, p = (t, e, n) => (null == e ? e = { key: n } : e.key = n, Ht(t, e)), I = p, Wt = H`*,*:before,*:after{box-sizing:border-box}button{padding:0;touch-action:manipulation;cursor:pointer;user-select:none}`, Jt = H`.vh{position:absolute;transform:scale(0)}`; function lt() { const t = new Date; return new v(t.getFullYear(), t.getMonth() + 1, t.getDate()) } function ut(t, e = 0) { const n = w(t), o = n.getUTCDay(), r = (o < e ? 7 : 0) + o - e; return n.setUTCDate(n.getUTCDate() - r), v.from(n) } function Zt(t, e = 0) { return ut(t, e).add({ days: 6 }) } function Xt(t) { return v.from(new Date(Date.UTC(t.year, t.month, 0))) } function K(t, e, n) { return e && v.compare(t, e) < 0 ? e : n && v.compare(t, n) > 0 ? n : t } const _e = { days: 1 }; function je(t, e = 0) { let n = ut(t.toPlainDate(), e); const o = Zt(Xt(t), e), r = []; for (; v.compare(n, o) < 0;) { const t = []; for (let e = 0; e < 7; e++)t.push(n), n = n.add(_e); r.push(t) } return r } function w(t) { return new Date(Date.UTC(t.year, t.month - 1, t.day ?? 1)) } const Ye = /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[0-1])$/, Q = (t, e) => t.toString().padStart(e, "0"); class v { constructor(t, e, n) { this.year = t, this.month = e, this.day = n } add(t) { const e = w(this); if ("days" in t) return e.setUTCDate(this.day + t.days), v.from(e); let { year: n, month: o } = this; "months" in t ? (o = this.month + t.months, e.setUTCMonth(o - 1)) : (n = this.year + t.years, e.setUTCFullYear(n)); const r = v.from(w({ year: n, month: o, day: 1 })); return K(v.from(e), r, Xt(r)) } toString() { return `${Q(this.year, 4)}-${Q(this.month, 2)}-${Q(this.day, 2)}` } toPlainYearMonth() { return new W(this.year, this.month) } equals(t) { return 0 === v.compare(this, t) } static compare(t, e) { return t.year < e.year ? -1 : t.year > e.year ? 1 : t.month < e.month ? -1 : t.month > e.month ? 1 : t.day < e.day ? -1 : t.day > e.day ? 1 : 0 } static from(t) { if ("string" == typeof t) { const e = t.match(Ye); if (!e) throw new TypeError(t); const [, n, o, r] = e; return new v(parseInt(n, 10), parseInt(o, 10), parseInt(r, 10)) } return new v(t.getUTCFullYear(), t.getUTCMonth() + 1, t.getUTCDate()) } } class W { constructor(t, e) { this.year = t, this.month = e } add(t) { const e = w(this), n = (t.months ?? 0) + 12 * (t.years ?? 0); return e.setUTCMonth(e.getUTCMonth() + n), new W(e.getUTCFullYear(), e.getUTCMonth() + 1) } equals(t) { return this.year === t.year && this.month === t.month } toPlainDate() { return new v(this.year, this.month, 1) } } function z(t, e) { if (e) try { return t.from(e) } catch { } } function N(t) { const [e, n] = it(t); return [C((() => z(v, e)), [e]), t => n(t?.toString())] } function Be(t) { const [e = "", n] = it(t); return [C((() => { const [t, n] = e.split("/"), o = z(v, t), r = z(v, n); return o && r ? [o, r] : [] }), [e]), t => n(`${t[0]}/${t[1]}`)] } function qe(t) { const [e = "", n] = it(t); return [C((() => { const t = []; for (const n of e.trim().split(/\s+/)) { const e = z(v, n); e && t.push(e) } return t }), [e]), t => n(t.join(" "))] } function L(t, e) { return C((() => new Intl.DateTimeFormat(e, { timeZone: "UTC", ...t })), [e, t]) } function Ct(t, e, n) { const o = L(t, n); return C((() => { const t = [], n = new Date; for (var r = 0; r < 7; r++) { t[(n.getUTCDay() - e + 7) % 7] = o.format(n), n.setUTCDate(n.getUTCDate() + 1) } return t }), [e, o]) } const Pt = (t, e, n) => K(t, e, n) === t, Nt = t => t.target.matches(":dir(ltr)"), xe = { month: "long", day: "numeric" }, ze = { month: "long" }, He = { weekday: "long" }, V = { bubbles: !0 }; function Ke({ props: t, context: e }) { const { offset: n } = t, { firstDayOfWeek: o, isDateDisallowed: r, min: a, max: s, today: i, page: c, locale: l, focusedDate: u, formatWeekday: d } = e, h = i ?? lt(), p = Ct(He, o, l), f = Ct(C((() => ({ weekday: d })), [d]), o, l), y = L(xe, l), m = L(ze, l), b = C((() => c.start.add({ months: n })), [c, n]), g = C((() => je(b, o)), [b, o]), v = P("focusday", V), k = P("selectday", V), S = P("hoverday", V); function D(t) { v(K(t, a, s)) } function x(t) { let e; switch (t.key) { case "ArrowRight": e = u.add({ days: Nt(t) ? 1 : -1 }); break; case "ArrowLeft": e = u.add({ days: Nt(t) ? -1 : 1 }); break; case "ArrowDown": e = u.add({ days: 7 }); break; case "ArrowUp": e = u.add({ days: -7 }); break; case "PageUp": e = u.add(t.shiftKey ? { years: -1 } : { months: -1 }); break; case "PageDown": e = u.add(t.shiftKey ? { years: 1 } : { months: 1 }); break; case "Home": e = ut(u, o); break; case "End": e = Zt(u, o); break; default: return }D(e), t.preventDefault() } return { weeks: g, yearMonth: b, daysLong: p, daysVisible: f, formatter: m, getDayProps: function (t) { const n = b.equals(t); if (!e.showOutsideDays && !n) return; const o = t.equals(u), i = t.equals(h), c = w(t), l = r?.(c), d = !Pt(t, a, s); let p, f = ""; if ("range" === e.type) { const [n, o] = e.value, r = n?.equals(t), a = o?.equals(t); p = n && o && Pt(t, n, o), f = `${r ? "range-start" : ""} ${a ? "range-end" : ""} ${!p || r || a ? "" : "range-inner"}` } else p = "multi" === e.type ? e.value.some((e => e.equals(t))) : e.value?.equals(t); return { part: `button day day-${c.getDay()} ${n ? p ? "selected" : "" : "outside"} ${l ? "disallowed" : ""} ${i ? "today" : ""} ${e.getDayParts?.(c) ?? ""} ${f}`, tabindex: n && o ? 0 : -1, disabled: d, "aria-disabled": l ? "true" : void 0, "aria-pressed": n && p, "aria-current": i ? "date" : void 0, "aria-label": y.format(c), onkeydown: x, onclick() { l || k(t), D(t) }, onmouseover() { !l && !d && S(t) } } } } } const tt = lt(), ft = Le({ type: "date", firstDayOfWeek: 1, focusedDate: tt, page: { start: tt.toPlainYearMonth(), end: tt.toPlainYearMonth() } }); customElements.define("calendar-ctx", ft); const We = (t, e) => (e + t) % 7, Je = j((t => { const e = Ue(ft), n = ae(), o = Ke({ props: t, context: e }); return I("host", { shadowDom: !0, focus: function () { n.current.querySelector("button[tabindex='0']")?.focus() }, children: [p("div", { id: "h", part: "heading", children: o.formatter.format(w(o.yearMonth)) }), I("table", { ref: n, "aria-labelledby": "h", part: "table", children: [p("thead", { children: p("tr", { part: "tr head", children: o.daysLong.map(((t, n) => I("th", { part: `th day day-${We(e.firstDayOfWeek, n)}`, scope: "col", children: [p("span", { class: "vh", children: t }), p("span", { "aria-hidden": "true", children: o.daysVisible[n] })] }))) }) }), p("tbody", { children: o.weeks.map(((t, e) => p("tr", { part: "tr week", children: t.map(((t, e) => { const n = o.getDayProps(t); return p("td", { part: "td", children: n && p("button", { ...n, children: t.day }) }, e) })) }, e))) })] })] }) }), { props: { offset: { type: Number, value: 0 } }, styles: [Wt, Jt, H`:host{--color-accent: black;--color-text-on-accent: white;display:flex;flex-direction:column;gap:.25rem;text-align:center;inline-size:fit-content}table{border-collapse:collapse;font-size:.875rem}th{font-weight:700;block-size:2.25rem}td{padding-inline:0}button{color:inherit;font-size:inherit;background:transparent;border:0;font-variant-numeric:tabular-nums;block-size:2.25rem;inline-size:2.25rem}button:hover:where(:not(:disabled,[aria-disabled])){background:#0000000d}button:is([aria-pressed=true],:focus-visible){background:var(--color-accent);color:var(--color-text-on-accent)}button:focus-visible{outline:1px solid var(--color-text-on-accent);outline-offset:-2px}button:disabled,:host::part(outside),:host::part(disallowed){cursor:default;opacity:.5}`] }); function kt(t) { return p("button", { part: `button ${t.name} ${t.onclick ? "" : "disabled"}`, onclick: t.onclick, "aria-disabled": t.onclick ? null : "true", children: p("slot", { name: t.name, children: t.children }) }) } function dt(t) { const e = w(t.page.start), n = w(t.page.end); return I("div", { role: "group", "aria-labelledby": "h", part: "container", children: [p("div", { id: "h", class: "vh", "aria-live": "polite", "aria-atomic": "true", children: t.formatVerbose.formatRange(e, n) }), I("div", { part: "header", children: [p(kt, { name: "previous", onclick: t.previous, children: "Previous" }), p("slot", { part: "heading", name: "heading", children: p("div", { "aria-hidden": "true", children: t.format.formatRange(e, n) }) }), p(kt, { name: "next", onclick: t.next, children: "Next" })] }), p(ft, { value: t, onselectday: t.onSelect, onfocusday: t.onFocus, onhoverday: t.onHover, children: p("slot", {}) })] }) } customElements.define("calendar-month", Je); const ht = { value: { type: String, value: "" }, min: { type: String, value: "" }, max: { type: String, value: "" }, today: { type: String, value: "" }, isDateDisallowed: { type: Function, value: t => !1 }, formatWeekday: { type: String, value: () => "narrow" }, getDayParts: { type: Function, value: t => "" }, firstDayOfWeek: { type: Number, value: () => 1 }, showOutsideDays: { type: Boolean, value: !1 }, locale: { type: String, value: () => { } }, months: { type: Number, value: 1 }, focusedDate: { type: String, value: () => { } }, pageBy: { type: String, value: () => "months" } }, mt = [Wt, Jt, H`:host{display:block;inline-size:fit-content}[role=group]{display:flex;flex-direction:column;gap:1em}:host::part(header){display:flex;align-items:center;justify-content:space-between}:host::part(heading){font-weight:700;font-size:1.25em}button{display:flex;align-items:center;justify-content:center}button[aria-disabled]{cursor:default;opacity:.5}`], Ze = { year: "numeric" }, Xe = { year: "numeric", month: "long" }; function et(t, e) { return 12 * (e.year - t.year) + e.month - t.month } const Ot = (t, e) => ({ start: t = 12 === e ? new W(t.year, 1) : t, end: t.add({ months: e - 1 }) }); function Ge({ pageBy: t, focusedDate: e, months: n, max: o, min: r, goto: a }) { const s = "single" === t ? 1 : n, [i, c] = ct((() => Ot(e.toPlainYearMonth(), n))), l = t => c(Ot(i.start.add({ months: t }), n)), u = t => { const e = et(i.start, t.toPlainYearMonth()); return e >= 0 && e < n }; return U((() => { if (u(e)) return; const t = et(e.toPlainYearMonth(), i.start); a(e.add({ months: t })) }), [i.start]), U((() => { if (u(e)) return; const t = et(i.start, e.toPlainYearMonth()); l(-1 === t ? -s : t === n ? s : Math.floor(t / n) * n) }), [e, s, n]), { page: i, previous: r && u(r) ? void 0 : () => l(-s), next: o && u(o) ? void 0 : () => l(s) } } function yt({ months: t, pageBy: e, locale: n, focusedDate: o, setFocusedDate: r }) { const [a] = N("min"), [s] = N("max"), [i] = N("today"), c = P("focusday"), l = P("change"), u = C((() => K(o ?? i ?? lt(), a, s)), [o, i, a, s]); function d(t) { r(t), c(w(t)) } const { next: h, previous: p, page: f } = Ge({ pageBy: e, focusedDate: u, months: t, min: a, max: s, goto: d }), y = _(); function m(t) { const e = t?.target ?? "day"; "day" === e ? y.current.querySelectorAll("calendar-month").forEach((e => e.focus(t))) : y.current.shadowRoot.querySelector(`[part~='${e}']`).focus(t) } return { format: L(Ze, n), formatVerbose: L(Xe, n), page: f, focusedDate: u, dispatch: l, onFocus(t) { t.stopPropagation(), d(t.detail), setTimeout(m) }, min: a, max: s, today: i, next: h, previous: p, focus: m } } const Qe = j((t => { const [e, n] = N("value"), [o = e, r] = N("focusedDate"), a = yt({ ...t, focusedDate: o, setFocusedDate: r }); return p("host", { shadowDom: !0, focus: a.focus, children: p(dt, { ...t, ...a, type: "date", value: e, onSelect: function (t) { n(t.detail), a.dispatch() } }) }) }), { props: ht, styles: mt }); customElements.define("calendar-date", Qe); const Mt = (t, e) => v.compare(t, e) < 0 ? [t, e] : [e, t], Ve = j((t => { const [e, n] = Be("value"), [o = e[0], r] = N("focusedDate"), a = yt({ ...t, focusedDate: o, setFocusedDate: r }), s = P("rangestart"), i = P("rangeend"), [c, l] = N("tentative"), [u, d] = ct(); function h(t) { t.stopPropagation(), c && d(t.detail) } U((() => d(void 0)), [c]); const f = c ? Mt(c, u ?? c) : e; return p("host", { shadowDom: !0, focus: a.focus, children: p(dt, { ...t, ...a, type: "range", value: f, onFocus: function (t) { a.onFocus(t), h(t) }, onHover: h, onSelect: function (t) { const e = t.detail; t.stopPropagation(), c ? (n(Mt(c, e)), l(void 0), i(w(e)), a.dispatch()) : (l(e), s(w(e))) } }) }) }), { props: { ...ht, tentative: { type: String, value: "" } }, styles: mt }); customElements.define("calendar-range", Ve); const tn = j((t => { const [e, n] = qe("value"), [o = e[0], r] = N("focusedDate"), a = yt({ ...t, focusedDate: o, setFocusedDate: r }); return p("host", { shadowDom: !0, focus: a.focus, children: p(dt, { ...t, ...a, type: "multi", value: e, onSelect: function (t) { const o = [...e], r = e.findIndex((e => e.equals(t.detail))); r < 0 ? o.push(t.detail) : o.splice(r, 1), n(o), a.dispatch() } }) }) }), { props: ht, styles: mt }); customElements.define("calendar-multi", tn); export { Qe as CalendarDate, Je as CalendarMonth, tn as CalendarMulti, Ve as CalendarRange };